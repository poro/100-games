<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout - Step 5: Ball-Paddle Collision</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #1a1a2e;
            font-family: Arial, sans-serif;
            color: #eee;
        }
        canvas {
            background-color: #16213e;
            border: 4px solid #e94560;
            border-radius: 8px;
        }
        h1 { margin-bottom: 10px; color: #4ecca3; }
        .instructions {
            margin-top: 15px;
            opacity: 0.7;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Breakout - Step 5: Paddle Bounce</h1>
    <canvas id="gameCanvas" width="480" height="320"></canvas>
    <div class="instructions">
        Keep the ball in play!<br>
        Where you hit the paddle affects the bounce angle!
    </div>

    <script>
        // ============================================================
        // STEP 5: BALL-PADDLE COLLISION
        // ============================================================
        // The ball should bounce off the paddle, not go through it.
        // We'll also add an important feature:
        // WHERE you hit the paddle affects the bounce angle!
        // - Hit center: ball goes straight up
        // - Hit left edge: ball goes up-left
        // - Hit right edge: ball goes up-right
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ============================================================
        // GAME OBJECTS
        // ============================================================
        
        const paddle = {
            width: 80,
            height: 12,
            x: 0,
            y: 0,
            color: '#4ecca3',
            speed: 8,
            dx: 0
        };
        
        paddle.x = (canvas.width - paddle.width) / 2;
        paddle.y = canvas.height - paddle.height - 20;
        
        const ball = {
            x: canvas.width / 2,
            y: canvas.height - 100,
            radius: 8,
            dx: 3,
            dy: -4,
            speed: 5,  // Base speed - we'll maintain this
            color: '#eee'
        };
        
        // ============================================================
        // GAME STATE
        // ============================================================
        let lives = 3;
        let gameRunning = true;
        
        // ============================================================
        // INPUT HANDLING
        // ============================================================
        const keys = { left: false, right: false };
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
            if (['ArrowLeft', 'ArrowRight'].includes(e.key)) e.preventDefault();
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            paddle.x = e.clientX - rect.left - paddle.width / 2;
            constrainPaddle();
        });
        
        // ============================================================
        // PADDLE FUNCTIONS
        // ============================================================
        
        function constrainPaddle() {
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > canvas.width) {
                paddle.x = canvas.width - paddle.width;
            }
        }
        
        function updatePaddle() {
            if (keys.left) paddle.dx = -paddle.speed;
            else if (keys.right) paddle.dx = paddle.speed;
            else paddle.dx = 0;
            
            paddle.x += paddle.dx;
            constrainPaddle();
        }
        
        // ============================================================
        // BALL-PADDLE COLLISION
        // ============================================================
        
        /**
         * Checks if the ball is colliding with the paddle.
         * 
         * For a circle-rectangle collision, we check:
         * 1. Is the ball's bottom edge at or below the paddle's top?
         * 2. Is the ball's center within the paddle's horizontal range?
         * 3. Is the ball moving downward? (to prevent multiple bounces)
         */
        function checkPaddleCollision() {
            // Ball's bottom edge
            const ballBottom = ball.y + ball.radius;
            
            // Paddle's top edge
            const paddleTop = paddle.y;
            
            // Check vertical collision
            // Ball must be at the paddle's level and moving down
            if (ballBottom >= paddleTop && 
                ballBottom <= paddleTop + paddle.height &&
                ball.dy > 0) {
                
                // Check horizontal collision
                // Ball center must be within paddle's horizontal range
                // (with some tolerance for the radius)
                if (ball.x >= paddle.x - ball.radius && 
                    ball.x <= paddle.x + paddle.width + ball.radius) {
                    
                    // COLLISION DETECTED!
                    handlePaddleBounce();
                    return true;
                }
            }
            
            return false;
        }
        
        /**
         * Handles the bounce physics when the ball hits the paddle.
         * 
         * KEY INSIGHT: Where the ball hits affects the bounce angle!
         * This gives the player CONTROL over where the ball goes.
         * 
         * We calculate a "hit position" from -1 (left edge) to +1 (right edge)
         * This affects the horizontal velocity.
         */
        function handlePaddleBounce() {
            // Move ball above the paddle to prevent sticking
            ball.y = paddle.y - ball.radius;
            
            // ============================================================
            // CALCULATING BOUNCE ANGLE
            // ============================================================
            // 
            //  Paddle: [========|========]
            //          -1      0       +1
            //           \      |       /
            //            \     |      /     ← Ball bounce direction
            //             \    |     /
            //
            // Hit the left edge? Ball goes up-left
            // Hit the center? Ball goes straight up
            // Hit the right edge? Ball goes up-right
            
            // Calculate where on the paddle the ball hit (0 to 1)
            const hitPosition = (ball.x - paddle.x) / paddle.width;
            
            // Convert to -1 to +1 range
            // 0 on paddle → -1 (leftmost)
            // 0.5 on paddle → 0 (center)
            // 1 on paddle → +1 (rightmost)
            const hitOffset = (hitPosition - 0.5) * 2;
            
            // Set new horizontal velocity based on hit position
            // The offset affects how much horizontal speed the ball gets
            const maxAngleInfluence = 5;  // Maximum horizontal speed change
            ball.dx = hitOffset * maxAngleInfluence;
            
            // Reverse vertical direction (always bounce up)
            ball.dy = -Math.abs(ball.dy);
            
            // ============================================================
            // MAINTAIN CONSISTENT SPEED
            // ============================================================
            // After changing dx, the ball might be too fast or slow.
            // We normalize the velocity to maintain consistent speed.
            
            const currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
            const speedRatio = ball.speed / currentSpeed;
            ball.dx *= speedRatio;
            ball.dy *= speedRatio;
            
            console.log(`Paddle hit at ${(hitOffset * 100).toFixed(0)}%: dx=${ball.dx.toFixed(2)}`);
        }
        
        // ============================================================
        // BALL UPDATE
        // ============================================================
        
        function updateBall() {
            ball.x += ball.dx;
            ball.y += ball.dy;
            
            // Wall collisions
            if (ball.x - ball.radius < 0) {
                ball.x = ball.radius;
                ball.dx = -ball.dx;
            }
            if (ball.x + ball.radius > canvas.width) {
                ball.x = canvas.width - ball.radius;
                ball.dx = -ball.dx;
            }
            if (ball.y - ball.radius < 0) {
                ball.y = ball.radius;
                ball.dy = -ball.dy;
            }
            
            // Paddle collision
            checkPaddleCollision();
            
            // Ball fell below screen!
            if (ball.y + ball.radius > canvas.height) {
                lives--;
                console.log(`Ball lost! Lives: ${lives}`);
                
                if (lives > 0) {
                    // Reset ball position
                    resetBall();
                } else {
                    gameRunning = false;
                    console.log('GAME OVER!');
                }
            }
        }
        
        /**
         * Resets the ball to starting position.
         */
        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height - 100;
            ball.dx = (Math.random() > 0.5 ? 1 : -1) * 3;  // Random direction
            ball.dy = -4;
        }
        
        // ============================================================
        // DRAWING FUNCTIONS
        // ============================================================
        
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        function drawPaddle() {
            ctx.fillStyle = paddle.color;
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            
            const radius = paddle.height / 2;
            ctx.beginPath();
            ctx.arc(paddle.x + radius, paddle.y + radius, radius, 0.5 * Math.PI, 1.5 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(paddle.x + paddle.width - radius, paddle.y + radius, radius, 1.5 * Math.PI, 0.5 * Math.PI);
            ctx.fill();
        }
        
        function drawBall() {
            ctx.fillStyle = ball.color;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawUI() {
            ctx.fillStyle = '#eee';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Lives: ${'❤️'.repeat(lives)}`, 10, 20);
            
            if (!gameRunning) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#e94560';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
            }
        }
        
        // ============================================================
        // GAME LOOP
        // ============================================================
        
        function update() {
            if (!gameRunning) return;
            updatePaddle();
            updateBall();
        }
        
        function draw() {
            clearCanvas();
            drawPaddle();
            drawBall();
            drawUI();
        }
        
        function gameLoop() {
            update();
            draw();
        }
        
        function animate() {
            gameLoop();
            requestAnimationFrame(animate);
        }
        
        animate();
        
        // ============================================================
        // WHAT WE LEARNED IN THIS STEP:
        // ============================================================
        // 1. Circle-rectangle collision uses edges and overlap
        // 2. Hit position (-1 to +1) gives player control over angle
        // 3. Speed normalization keeps ball at consistent velocity
        // 4. We need to check ball is moving DOWN before bouncing
        // 5. Lives system and game over state
        //
        // NEXT STEP: Add the bricks!
        // ============================================================
        
        console.log('Step 5 Complete! The ball bounces off the paddle.');
        console.log('Try hitting different parts of the paddle!');
    </script>
</body>
</html>
