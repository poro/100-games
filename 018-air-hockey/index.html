<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Air Hockey</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        h1 {
            color: #fff;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(0, 200, 255, 0.5);
        }

        .scoreboard {
            display: flex;
            gap: 40px;
            margin-bottom: 15px;
            font-size: clamp(1rem, 3vw, 1.5rem);
            color: #fff;
        }

        .score {
            padding: 10px 25px;
            border-radius: 10px;
            min-width: 120px;
            text-align: center;
        }

        .score.player1 {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }

        .score.player2 {
            background: linear-gradient(135deg, #3498db, #2980b9);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }

        .score span {
            font-weight: bold;
            font-size: 1.4em;
        }

        #gameContainer {
            position: relative;
        }

        #gameCanvas {
            border-radius: 20px;
            box-shadow: 0 0 40px rgba(0, 200, 255, 0.3),
                        inset 0 0 100px rgba(0, 0, 0, 0.3);
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 12px 30px;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00d4aa, #00a885);
            color: #fff;
            box-shadow: 0 4px 15px rgba(0, 212, 170, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: #fff;
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.4);
        }

        button:hover {
            transform: translateY(-2px);
            filter: brightness(1.1);
        }

        button:active {
            transform: translateY(0);
        }

        .instructions {
            color: rgba(255, 255, 255, 0.7);
            font-size: clamp(0.7rem, 1.5vw, 0.9rem);
            margin-top: 15px;
            text-align: center;
            max-width: 600px;
            line-height: 1.5;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal.active {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            background: linear-gradient(135deg, #2d3436, #1e272e);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: #fff;
            box-shadow: 0 0 50px rgba(0, 200, 255, 0.3);
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }

        .modal.active .modal-content {
            transform: scale(1);
        }

        .modal h2 {
            font-size: 2rem;
            margin-bottom: 20px;
        }

        .modal p {
            font-size: 1.2rem;
            margin-bottom: 25px;
            color: rgba(255, 255, 255, 0.8);
        }

        .winner-red { color: #e74c3c; }
        .winner-blue { color: #3498db; }

        @media (max-width: 600px) {
            .scoreboard {
                gap: 20px;
            }
            .score {
                padding: 8px 15px;
                min-width: 90px;
            }
            .controls {
                gap: 10px;
            }
            button {
                padding: 10px 20px;
            }
        }
    </style>
</head>
<body>
    <h1>üèí Air Hockey</h1>
    
    <div class="scoreboard">
        <div class="score player1">
            P1: <span id="score1">0</span>
        </div>
        <div class="score player2">
            P2: <span id="score2">0</span>
        </div>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="controls">
        <button class="btn-primary" id="restartBtn">New Game</button>
        <button class="btn-secondary" id="modeBtn">Switch to AI</button>
    </div>

    <div class="instructions">
        <strong>Player 1 (Red):</strong> WASD keys | 
        <strong>Player 2 (Blue):</strong> Arrow keys<br>
        <strong>Mobile:</strong> Touch and drag in your half of the table<br>
        First to 5 wins!
    </div>

    <div class="modal" id="winModal">
        <div class="modal-content">
            <h2 id="winnerText">Player Wins!</h2>
            <p id="finalScore">5 - 3</p>
            <button class="btn-primary" id="playAgainBtn">Play Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Responsive canvas sizing
        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth - 40, 800);
            const maxHeight = Math.min(window.innerHeight - 280, 500);
            const ratio = 1.6; // width:height ratio
            
            if (maxWidth / ratio <= maxHeight) {
                canvas.width = maxWidth;
                canvas.height = maxWidth / ratio;
            } else {
                canvas.height = maxHeight;
                canvas.width = maxHeight * ratio;
            }
            
            // Update game dimensions
            game.width = canvas.width;
            game.height = canvas.height;
            game.goalWidth = canvas.height * 0.35;
            game.paddleRadius = Math.min(canvas.width, canvas.height) * 0.06;
            game.puckRadius = Math.min(canvas.width, canvas.height) * 0.04;
            game.goalDepth = canvas.width * 0.02;
        }

        // Game state
        const game = {
            width: 800,
            height: 500,
            goalWidth: 175,
            goalDepth: 16,
            paddleRadius: 35,
            puckRadius: 25,
            friction: 0.995,
            wallBounce: 0.8,
            paddleBounce: 1.15,
            maxPuckSpeed: 20,
            score: [0, 0],
            winScore: 5,
            isAI: false,
            paused: false,
            goalScored: false,
            goalTimer: 0
        };

        // Players
        const player1 = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            targetX: 0,
            targetY: 0,
            speed: 8,
            color: '#e74c3c',
            colorLight: '#ff6b6b'
        };

        const player2 = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            targetX: 0,
            targetY: 0,
            speed: 8,
            color: '#3498db',
            colorLight: '#5dade2'
        };

        // Puck
        const puck = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            color: '#f1c40f',
            colorLight: '#f9e79f'
        };

        // Input state
        const keys = {};
        const touches = {};

        // Initialize positions
        function resetPositions(scorer = null) {
            player1.x = game.width * 0.2;
            player1.y = game.height / 2;
            player1.vx = 0;
            player1.vy = 0;
            player1.targetX = player1.x;
            player1.targetY = player1.y;

            player2.x = game.width * 0.8;
            player2.y = game.height / 2;
            player2.vx = 0;
            player2.vy = 0;
            player2.targetX = player2.x;
            player2.targetY = player2.y;

            puck.x = game.width / 2;
            puck.y = game.height / 2;
            
            // Give puck initial velocity toward scorer's side
            if (scorer === 1) {
                puck.vx = 3;
                puck.vy = (Math.random() - 0.5) * 4;
            } else if (scorer === 2) {
                puck.vx = -3;
                puck.vy = (Math.random() - 0.5) * 4;
            } else {
                puck.vx = (Math.random() > 0.5 ? 1 : -1) * 3;
                puck.vy = (Math.random() - 0.5) * 4;
            }
        }

        // Draw the rink
        function drawRink() {
            // Table surface
            const gradient = ctx.createLinearGradient(0, 0, game.width, 0);
            gradient.addColorStop(0, '#1a5c4c');
            gradient.addColorStop(0.5, '#1e7e67');
            gradient.addColorStop(1, '#1a5c4c');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, game.width, game.height);

            // Center line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 3;
            ctx.setLineDash([15, 10]);
            ctx.beginPath();
            ctx.moveTo(game.width / 2, 0);
            ctx.lineTo(game.width / 2, game.height);
            ctx.stroke();
            ctx.setLineDash([]);

            // Center circle
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(game.width / 2, game.height / 2, game.height * 0.2, 0, Math.PI * 2);
            ctx.stroke();

            // Center dot
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(game.width / 2, game.height / 2, 5, 0, Math.PI * 2);
            ctx.fill();

            // Goals
            const goalTop = (game.height - game.goalWidth) / 2;
            const goalBottom = goalTop + game.goalWidth;

            // Left goal (red)
            ctx.fillStyle = 'rgba(231, 76, 60, 0.6)';
            ctx.fillRect(0, goalTop, game.goalDepth, game.goalWidth);
            ctx.strokeStyle = '#c0392b';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(game.goalDepth, goalTop);
            ctx.lineTo(0, goalTop);
            ctx.lineTo(0, goalBottom);
            ctx.lineTo(game.goalDepth, goalBottom);
            ctx.stroke();

            // Right goal (blue)
            ctx.fillStyle = 'rgba(52, 152, 219, 0.6)';
            ctx.fillRect(game.width - game.goalDepth, goalTop, game.goalDepth, game.goalWidth);
            ctx.strokeStyle = '#2980b9';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(game.width - game.goalDepth, goalTop);
            ctx.lineTo(game.width, goalTop);
            ctx.lineTo(game.width, goalBottom);
            ctx.lineTo(game.width - game.goalDepth, goalBottom);
            ctx.stroke();

            // Border
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 8;
            ctx.strokeRect(4, 4, game.width - 8, game.height - 8);
        }

        // Draw paddle
        function drawPaddle(paddle) {
            // Outer glow
            ctx.shadowColor = paddle.color;
            ctx.shadowBlur = 20;
            
            // Main paddle
            const gradient = ctx.createRadialGradient(
                paddle.x - game.paddleRadius * 0.3, 
                paddle.y - game.paddleRadius * 0.3, 
                0,
                paddle.x, paddle.y, game.paddleRadius
            );
            gradient.addColorStop(0, paddle.colorLight);
            gradient.addColorStop(1, paddle.color);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(paddle.x, paddle.y, game.paddleRadius, 0, Math.PI * 2);
            ctx.fill();

            // Inner circle
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(paddle.x, paddle.y, game.paddleRadius * 0.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Draw puck
        function drawPuck() {
            // Puck shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(puck.x + 3, puck.y + 3, game.puckRadius, game.puckRadius * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Puck glow
            ctx.shadowColor = puck.color;
            ctx.shadowBlur = 15;

            // Main puck
            const gradient = ctx.createRadialGradient(
                puck.x - game.puckRadius * 0.3,
                puck.y - game.puckRadius * 0.3,
                0,
                puck.x, puck.y, game.puckRadius
            );
            gradient.addColorStop(0, puck.colorLight);
            gradient.addColorStop(1, puck.color);

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(puck.x, puck.y, game.puckRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;

            // Puck edge
            ctx.strokeStyle = '#d68910';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Handle player input
        function handleInput() {
            // Player 1 (WASD)
            let p1dx = 0, p1dy = 0;
            if (keys['KeyW'] || keys['w']) p1dy -= 1;
            if (keys['KeyS'] || keys['s']) p1dy += 1;
            if (keys['KeyA'] || keys['a']) p1dx -= 1;
            if (keys['KeyD'] || keys['d']) p1dx += 1;

            if (p1dx !== 0 || p1dy !== 0) {
                const len = Math.sqrt(p1dx * p1dx + p1dy * p1dy);
                player1.vx = (p1dx / len) * player1.speed;
                player1.vy = (p1dy / len) * player1.speed;
            } else if (!touches.player1) {
                player1.vx *= 0.85;
                player1.vy *= 0.85;
            }

            // Player 2 (Arrow keys) - only if not AI
            if (!game.isAI) {
                let p2dx = 0, p2dy = 0;
                if (keys['ArrowUp']) p2dy -= 1;
                if (keys['ArrowDown']) p2dy += 1;
                if (keys['ArrowLeft']) p2dx -= 1;
                if (keys['ArrowRight']) p2dx += 1;

                if (p2dx !== 0 || p2dy !== 0) {
                    const len = Math.sqrt(p2dx * p2dx + p2dy * p2dy);
                    player2.vx = (p2dx / len) * player2.speed;
                    player2.vy = (p2dy / len) * player2.speed;
                } else if (!touches.player2) {
                    player2.vx *= 0.85;
                    player2.vy *= 0.85;
                }
            }

            // Touch input
            if (touches.player1) {
                const dx = touches.player1.x - player1.x;
                const dy = touches.player1.y - player1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 2) {
                    const speed = Math.min(dist * 0.3, player1.speed * 1.5);
                    player1.vx = (dx / dist) * speed;
                    player1.vy = (dy / dist) * speed;
                }
            }

            if (touches.player2 && !game.isAI) {
                const dx = touches.player2.x - player2.x;
                const dy = touches.player2.y - player2.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 2) {
                    const speed = Math.min(dist * 0.3, player2.speed * 1.5);
                    player2.vx = (dx / dist) * speed;
                    player2.vy = (dy / dist) * speed;
                }
            }
        }

        // AI logic
        function updateAI() {
            if (!game.isAI) return;

            const targetX = puck.x > game.width / 2 ? puck.x - game.paddleRadius : game.width * 0.8;
            const targetY = puck.y;

            // Predict puck position
            let predY = puck.y;
            if (puck.vx > 0) {
                const timeToReach = (player2.x - puck.x) / puck.vx;
                predY = puck.y + puck.vy * timeToReach * 0.7;
            }

            // Clamp prediction
            predY = Math.max(game.paddleRadius, Math.min(game.height - game.paddleRadius, predY));

            // Move toward predicted position
            const dx = (puck.x > game.width * 0.4 ? puck.x - game.paddleRadius * 0.5 : game.width * 0.8) - player2.x;
            const dy = predY - player2.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 5) {
                const speed = Math.min(player2.speed * 0.85, dist * 0.15);
                player2.vx = (dx / dist) * speed;
                player2.vy = (dy / dist) * speed;
            } else {
                player2.vx *= 0.9;
                player2.vy *= 0.9;
            }
        }

        // Update paddle positions
        function updatePaddles() {
            // Player 1 - left half only
            player1.x += player1.vx;
            player1.y += player1.vy;
            player1.x = Math.max(game.paddleRadius + game.goalDepth, 
                                 Math.min(game.width / 2 - game.paddleRadius, player1.x));
            player1.y = Math.max(game.paddleRadius, 
                                 Math.min(game.height - game.paddleRadius, player1.y));

            // Player 2 - right half only
            player2.x += player2.vx;
            player2.y += player2.vy;
            player2.x = Math.max(game.width / 2 + game.paddleRadius, 
                                 Math.min(game.width - game.paddleRadius - game.goalDepth, player2.x));
            player2.y = Math.max(game.paddleRadius, 
                                 Math.min(game.height - game.paddleRadius, player2.y));
        }

        // Circle collision
        function circleCollision(c1, r1, c2, r2) {
            const dx = c2.x - c1.x;
            const dy = c2.y - c1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist < r1 + r2;
        }

        // Handle puck-paddle collision
        function handlePaddleCollision(paddle) {
            const dx = puck.x - paddle.x;
            const dy = puck.y - paddle.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const minDist = game.puckRadius + game.paddleRadius;

            if (dist < minDist) {
                // Normalize
                const nx = dx / dist;
                const ny = dy / dist;

                // Separate
                const overlap = minDist - dist;
                puck.x += nx * overlap;
                puck.y += ny * overlap;

                // Relative velocity
                const relVx = puck.vx - paddle.vx;
                const relVy = puck.vy - paddle.vy;

                // Relative velocity in collision normal direction
                const velAlongNormal = relVx * nx + relVy * ny;

                // Only resolve if velocities are separating
                if (velAlongNormal < 0) {
                    // Calculate impulse
                    const impulse = -(1 + game.paddleBounce) * velAlongNormal;

                    puck.vx += impulse * nx + paddle.vx * 0.5;
                    puck.vy += impulse * ny + paddle.vy * 0.5;

                    // Limit speed
                    const speed = Math.sqrt(puck.vx * puck.vx + puck.vy * puck.vy);
                    if (speed > game.maxPuckSpeed) {
                        puck.vx = (puck.vx / speed) * game.maxPuckSpeed;
                        puck.vy = (puck.vy / speed) * game.maxPuckSpeed;
                    }
                }
            }
        }

        // Update puck
        function updatePuck() {
            if (game.goalScored) return;

            puck.x += puck.vx;
            puck.y += puck.vy;

            // Apply friction
            puck.vx *= game.friction;
            puck.vy *= game.friction;

            // Wall collisions
            const goalTop = (game.height - game.goalWidth) / 2;
            const goalBottom = goalTop + game.goalWidth;

            // Top and bottom walls
            if (puck.y - game.puckRadius < 0) {
                puck.y = game.puckRadius;
                puck.vy = -puck.vy * game.wallBounce;
            }
            if (puck.y + game.puckRadius > game.height) {
                puck.y = game.height - game.puckRadius;
                puck.vy = -puck.vy * game.wallBounce;
            }

            // Left wall / goal check
            if (puck.x - game.puckRadius < game.goalDepth) {
                if (puck.y > goalTop && puck.y < goalBottom) {
                    // GOAL for player 2!
                    scoreGoal(2);
                    return;
                } else {
                    puck.x = game.goalDepth + game.puckRadius;
                    puck.vx = -puck.vx * game.wallBounce;
                }
            }

            // Right wall / goal check
            if (puck.x + game.puckRadius > game.width - game.goalDepth) {
                if (puck.y > goalTop && puck.y < goalBottom) {
                    // GOAL for player 1!
                    scoreGoal(1);
                    return;
                } else {
                    puck.x = game.width - game.goalDepth - game.puckRadius;
                    puck.vx = -puck.vx * game.wallBounce;
                }
            }

            // Paddle collisions
            handlePaddleCollision(player1);
            handlePaddleCollision(player2);
        }

        // Score goal
        function scoreGoal(player) {
            game.score[player - 1]++;
            updateScoreboard();
            game.goalScored = true;
            game.goalTimer = 60; // frames

            // Check for winner
            if (game.score[player - 1] >= game.winScore) {
                showWinner(player);
            }
        }

        // Update scoreboard
        function updateScoreboard() {
            document.getElementById('score1').textContent = game.score[0];
            document.getElementById('score2').textContent = game.score[1];
        }

        // Show winner modal
        function showWinner(player) {
            const modal = document.getElementById('winModal');
            const winnerText = document.getElementById('winnerText');
            const finalScore = document.getElementById('finalScore');

            const name = game.isAI && player === 2 ? 'AI' : `Player ${player}`;
            winnerText.textContent = `${name} Wins!`;
            winnerText.className = player === 1 ? 'winner-red' : 'winner-blue';
            finalScore.textContent = `${game.score[0]} - ${game.score[1]}`;

            modal.classList.add('active');
            game.paused = true;
        }

        // Reset game
        function resetGame() {
            game.score = [0, 0];
            game.paused = false;
            game.goalScored = false;
            game.goalTimer = 0;
            updateScoreboard();
            resetPositions();
            document.getElementById('winModal').classList.remove('active');
        }

        // Draw goal scored effect
        function drawGoalEffect() {
            if (!game.goalScored) return;

            const alpha = Math.sin(game.goalTimer * 0.2) * 0.3 + 0.3;
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.fillRect(0, 0, game.width, game.height);

            ctx.fillStyle = '#fff';
            ctx.font = `bold ${game.width * 0.1}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = '#000';
            ctx.shadowBlur = 10;
            ctx.fillText('GOAL!', game.width / 2, game.height / 2);
            ctx.shadowBlur = 0;
        }

        // Main game loop
        function gameLoop() {
            if (!game.paused) {
                if (game.goalScored) {
                    game.goalTimer--;
                    if (game.goalTimer <= 0) {
                        game.goalScored = false;
                        const lastScorer = game.score[0] > game.score[1] ? 1 : 2;
                        resetPositions(lastScorer);
                    }
                } else {
                    handleInput();
                    updateAI();
                    updatePaddles();
                    updatePuck();
                }
            }

            // Draw
            drawRink();
            drawPaddle(player1);
            drawPaddle(player2);
            drawPuck();
            drawGoalEffect();

            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.code || e.key] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code || e.key] = false;
        });

        // Touch handling
        function getTouchPosition(touch) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (touch.clientX - rect.left) * (canvas.width / rect.width),
                y: (touch.clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                const pos = getTouchPosition(touch);
                if (pos.x < game.width / 2) {
                    touches.player1 = { id: touch.identifier, x: pos.x, y: pos.y };
                } else if (!game.isAI) {
                    touches.player2 = { id: touch.identifier, x: pos.x, y: pos.y };
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                const pos = getTouchPosition(touch);
                if (touches.player1 && touches.player1.id === touch.identifier) {
                    touches.player1.x = Math.min(pos.x, game.width / 2 - game.paddleRadius);
                    touches.player1.y = pos.y;
                }
                if (touches.player2 && touches.player2.id === touch.identifier) {
                    touches.player2.x = Math.max(pos.x, game.width / 2 + game.paddleRadius);
                    touches.player2.y = pos.y;
                }
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                if (touches.player1 && touches.player1.id === touch.identifier) {
                    touches.player1 = null;
                }
                if (touches.player2 && touches.player2.id === touch.identifier) {
                    touches.player2 = null;
                }
            }
        });

        // Buttons
        document.getElementById('restartBtn').addEventListener('click', resetGame);
        document.getElementById('playAgainBtn').addEventListener('click', resetGame);
        
        document.getElementById('modeBtn').addEventListener('click', () => {
            game.isAI = !game.isAI;
            document.getElementById('modeBtn').textContent = game.isAI ? 'Switch to 2P' : 'Switch to AI';
            document.querySelector('.score.player2').innerHTML = game.isAI ? 
                'AI: <span id="score2">' + game.score[1] + '</span>' :
                'P2: <span id="score2">' + game.score[1] + '</span>';
            resetGame();
        });

        // Handle resize
        window.addEventListener('resize', resizeCanvas);

        // Initialize
        resizeCanvas();
        resetPositions();
        gameLoop();
    </script>
</body>
</html>
